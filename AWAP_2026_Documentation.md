# AWAP 2026 Opening Ceremony

Join the Discord !
 https://discord.gg/G7k63AYd

AWAP 2026 
— Opening Ceremony — 
Presented by  ACM@CMU

This event wouldn’t be possible without…

THE T alk

Carnegie Cookoff

Premise 
T w o  noodle shops. 
O n e  street. 
Z e r o  mercy . 
Y ou open your doors with a  dream and a burner stove. Across the street, your rival does the same. 
Orders ﬂood in. T empers ﬂare. Claws  come out, t e eth  bared. The broth gets hotter . 
Make money. Complete orders. PURR -fect your noodles. Build your empire. 
WHEN NIGHT FALLS, sabotage your enemy and create a CAT -astrophe — but beware. But every 
hiss echoes back. 
When the dust settles, only one shop will still be standing. 
Welcome to the  NOODLE War .

What will you be doing? 
Y ou will be developing algorithms that will compete in a head-to-head cook-off with another 
team’s algorithm through preparing different orders and/or sabotaging each other on different 
layouts of the noodle shop. The algorithms would be tested for their efficiency and 
effectiveness .
The team ending with more money wins!

Gameplay ( GUIDE )
1. Create a team of bots to cook delicious meals 
2. Stock your Kitchen with Food, Plates, and Pans 
3. Chop , Cook, and Clean As you fulfill orders 
4. Fulfill orders to earn money 
5. Sabotage your opponent’s Kitchen to come up on top 
6. Whoever makes the most money wins!

Viewer tips 
1.You can drag around and zoom in the viewer to view the 3d 
scenes from different perspectives 
2. Scroll to zoom in/out, drag to view different angles, and 
command/control drag to move around the scene (specific 
commands may differ on device, ask us if you need help) 
3. Scene lightening color changes to dim yellow on turns when the 
bots is able switch maps 
4. There is a map maker in the viewer to help create custom maps 
as well (mostly used by organizers) 
5.Viewer at: https://www.acmatcmu.com/awap-viewer-2026/

Tournament Structure 
Unranked scrimmages, ranked scrimmages, and single elimination finals 
Can be requested at any 
time. Useful for testing. US 
1. Approx every 2 hours, 
starting at 4 PM 
2. Test your bot against 
others 
3. Your Elo will be updated 
during the ranked 
scrimmage RS 
1. You will be seeded by your 
ranked scrimmage rating 
2. These are only run at the 
end after the coding stops SEF

Account Setup 
1. Set up your account at https://dashboard.awap.acmatcmu.com/ 
2. Read the game engine documentation at https://bit.ly/awap2026docs  
We will send out the slides and links on the website and Discord. 
If you need any help, come by during Game Setup & FAQs, or reach out for help in #office-hours

Development Flow 
1. Clone game engine repo https://github.com/acm-cmu/awap-game-engine-2026-public  
2. Write your bot as a single Python ﬁle in bots folder 
3. Create a map using a mapmaker at view.awap.acmatcmu.com  or use one of the 5 maps 
that we gave. Put map in maps folder . 
4. Specify players & maps in “conﬁg.json” then run “python3 run_game.py -c conﬁg.json” 
5. View gameplay by uploading replay generated in replays folder to 
view.awap.acmatcmu.com 
6. Submit your favorite self-made maps for tournament play through discord!!!!

Check In 
Opening Ceremony 
Dinner 
Midnight Snack Schedule (Day 1) 
11am @ Rashid 
12pm @ Rango’s 
6:00pm (18:00) @ Rango’s 
11:00pm (23:00) @ Rango’s 
Office Hours @ 
Rango’s *
*Lunch 12:40pm @ Rango’s 
*

lunch 
Coding Stops 
cLOSING ceremony Schedule (Day 2) 
12pm (12:00) @ Rango’s 
5pm (17:00) 
7:00pm (19:00) @ Rango’s 
Office Hours @ 
Rango’s *
dINNER 5pm (17:00) @ Rango’s *

Street food is temporary. 
Glory  is forever .

Join our Discord, and 
enable all messages to 
receive important 
announcements

An epic and a romance 
Write a comprehensive explanation for the main difference between an epic and a romance in 
medieval literature! 
Write your answer here…

Allegory and symbolism 
Mercury is the closest 
planet to the Sun and the 
smallest of them all Mercury 
Venus has a beautiful 
name and is the second 
planet from the Sun Venus 
Despite being red, Mars is 
actually a cold place. It’s 
full of iron oxide dust Mars 50% 25% 25%

Computer 
mockup 
You can replace the image on the 
screen with your own work. Just 
right-click on it and select 
“Replace image”

Tablet mockup 
You can replace the image on 
the screen with your own work. 
Just right-click on it and select 
“Replace image”

Phone mockup 
You can replace the image on the 
screen with your own work. Just 
right-click on it and select 
“Replace image”

Medieval literature writer 
Geoffrey Chaucer 
Dante Alighieri 
Giovanni Boccaccio 
Thomas Malory The Divine Comedy 
The Canterbury Tales 
The Decameron 
Le Morte d’Arthur Match each author with their work:

Medieval literature history 
Venus Venus is the second 
planet from the Sun 
Mercury 
Mercury is the closest 
planet to the Sun Mars Despite being red, Mars 
is a very cold place 
Jupiter 
Jupiter is the biggest 
planet of them all

JANUARY FEBRUARY MARCH APRIL 
PHASE 1 
Task 1 
Task 2 JANUARY FEBRUARY MARCH APRIL MAY JUNE 
PHASE 1 
PHASE 2 Task 1 
Task 2 
Task 1 
Task 2



You can resize these icons without losing quality. 
You can change the stroke and fill color ; just select the icon and click on the paint bucket/pen .
In Google Slides, you can also use Flaticon’s extension , allowing you to customize and add even more icons. 
...and our sets of editable icons

Educational Icons Medical Icons

Business Icons Teamwork Icons

Help & Support Icons Avatar Icons

Creative Process Icons Performing Arts Icons

Nature Icons

SEO & Marketing Icons

# API Documentation

API
 
Documentation
 
You
 
can
 
ﬁnd
 
the
 
GitHub
 
repository
 
for
 
the
 
game
 
engine
 
here:
 
https://github.com/acm-cmu/awap-game-engine-2026-public
 
 
 
This
 
is
 
an
 
exhaustive
 
list
 
of
 
all
 
the
 
functions
 
or
 
methods
 
that
 
players
 
are
 
allowed
 
to
 
access.
 
If
 
you
 
have
 
any
 
remaining
 
questions
 
about
 
the
 
functionality,
 
please
 
reach
 
out
 
to
 
us
 
at
 
in
 
person
 
office
 
hours!
 
 
Note:
 
Please
 
do
 
not
 
attempt
 
to
 
exploit
 
the
 
game
 
engine
 
by
 
accessing
 
the
 
internal
 
state.
 
Attempting
 
to
 
do
 
so
 
may
 
result
 
in
 
disqualiﬁcation.
 
 
RobotController
 
These
 
are
 
all
 
the
 
member
 
functions
 
of
 
RobotController.
 
These
 
are
 
used
 
to
 
control
 
your
 
player
 
and
 
obtain
 
information
 
about
 
the
 
game
 
state.
 
RobotController
 
-
 
Main
 
Functionalities
 
State
 
Access
 
Functions
 
get_turn() -> int 
Gets
 
the
 
current
 
turn
 
of
 
the
 
game.
 
get_team() -> Team 
Returns
 
the
 
team
 
you
 
are
 
on,
 
returning
 
either
 
Team.RED
 
or
 
Team.BLUE.
 
get_enemy_team() -> Team 
Returns
 
your
 
opponent’s
 
team,
 
returning
 
either
 
Team.RED
 
or
 
Team.BLUE.
 
get_map() -> Map 
Returns
 
the
 
current
 
map
 
instance.
 
 
get_orders() -> List[Dict] 
Returns
 
the
 
list
 
of
 
orders,
 
with
 
each
 
order
 
represented
 
by
 
a
 
dictionary.

Dictionary
 
Items:
 
●
 
order_id:
 
id
 
number
 
for
 
the
 
order,
 
●
 
required:
 
the
 
names
 
of
 
the
 
foods
 
required,
 
●
 
created_turn:
 
the
 
turn
 
the
 
order
 
appears,
 
●
 
expires_turn:
 
the
 
turn
 
the
 
order
 
will
 
expire,
 
●
 
reward:
 
the
 
reward
 
for
 
successfully
 
submitting
 
the
 
order,
 
●
 
penalty:
 
penalty
 
for
 
letting
 
the
 
order
 
expire,
 
●
 
claimed_by:
 
the
 
id
 
of
 
the
 
bot
 
the
 
order
 
was
 
claimed
 
by,
 
●
 
completed_turn:
 
the
 
turn
 
that
 
the
 
order
 
was
 
submitted,
 
or
 
None,
 
●
 
is_active:
 
whether
 
or
 
not
 
the
 
order
 
is
 
currently
 
active,
 
get_team_bot_ids() -> List[int] 
Returns
 
the
 
bot
 
IDs
 
of
 
your
 
team
 
as
 
a
 
list.
 
get_team_money() -> int 
Returns
 
the
 
amount
 
of
 
money
 
your
 
team
 
currently
 
has.
 
get_bot_state(bot_id:int) -> Optional[Dict] 
Returns
 
the
 
state
 
of
 
the
 
given
 
bot
 
as
 
a
 
dictionary.
 
 
The
 
dictionary
 
contains:
 
●
 
bot_id:
 
the
 
bot
 
id
 
●
 
team:
 
the
 
team
 
name
 
●
 
x:
 
the
 
bot’s
 
x-coordinate
 
●
 
y:
 
the
 
bot’s
 
y-coordinate
 
●
 
team_money:
 
the
 
amount
 
of
 
money
 
the
 
team
 
has
 
●
 
holding:
 
the
 
item
 
the
 
bot
 
is
 
currently
 
holding
 
●
 
map_team:
 
the
 
team
 
associated
 
to
 
the
 
map
 
the
 
bot
 
is
 
currently
 
on
 
get_tile(team:Team, x:int, y:int) -> Optional[Tile] 
Returns
 
the
 
tile
 
at
 
the
 
given
 
(x,
 
y)
 
coordinate.
 
Movement
 
Functions
 
can_move(bot_id:int, dx:int, dy:int) -> bool 
Returns
 
whether
 
the
 
given
 
bot
 
can
 
move
 
to
 
coordinates
 
(dx,
 
dy).

move(bot_id: int, dx: int, dy: int) -> bool 
Moves
 
the
 
bot
 
to
 
coordinates
 
(dx,
 
dy);
 
returns
 
True
 
if
 
successful
 
and
 
False
 
if
 
not.
 
Inventory
 
Functions
 
pickup(bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Bot
 
picks
 
up
 
an
 
item
 
from
 
target
 
location
 
(target_x,
 
target_y);
 
returns
 
True
 
if
 
successful
 
and
 
False
 
if
 
not.
 
Can
 
be
 
used
 
to
 
pick
 
up
 
items
 
from
 
boxes.
 
place(bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Bot
 
places
 
an
 
item
 
at
 
target
 
location
 
(target_x,
 
target_y);
 
returns
 
True
 
if
 
successful
 
and
 
False
 
if
 
not.
 
Can
 
be
 
used
 
to
 
place
 
items
 
on
 
pans
 
and
 
boxes.
 
Placement
 
rules:
 
●
 
can
 
place
 
anything
 
in
 
an
 
empty
 
box
 
●
 
can
 
only
 
place
 
food
 
on
 
a
 
cooker
 
with
 
a
 
pan
 
on
 
it
 
trash(bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
If
 
coordinates
 
(target_x,
 
target_y)
 
are
 
the
 
coordinates
 
of
 
the
 
trash
 
tile,
 
the
 
bot
 
disposes
 
of:
 
●
 
the
 
food
 
item
 
it
 
is
 
currently
 
holding,
 
or
 
●
 
the
 
food
 
items
 
in
 
the
 
pan
 
or
 
plate
 
it
 
is
 
currently
 
holding
 
And
 
returns
 
True.
 
Otherwise,
 
trash
 
disposal
 
fails
 
and
 
False
 
is
 
returned.
 
Shop
 
Functions 
can_buy(bot_id: int, item: Buyable, target_x: Optional[int] = None, 
target_y:
 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Checks
 
if
 
the
 
bot
 
can
 
buy
 
an
 
item
 
from
 
the
 
shop.
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
a
 
shop
 
tile
 
●
 
bot
 
is
 
not
 
carrying
 
anything.
 
Returns
 
True
 
if
 
possible,
 
False
 
otherwise.

buy(bot_id: int, item: Buyable, target_x: Optional[int] = None, 
target_y:
 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Buys
 
an
 
item
 
from
 
the
 
shop.
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
a
 
shop
 
tile
 
●
 
bot
 
is
 
not
 
carrying
 
anything.
 
Returns
 
True
 
if
 
successful
 
False
 
otherwise.
 
Food
 
Processing
 
Functions
 
chop(bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Chops
 
food
 
on
 
a
 
counter;
 
returns
 
True
 
if
 
successful,
 
False
 
if
 
not.
 
 
can_start_cook(bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Check
 
if
 
the
 
bot
 
can
 
start
 
cooking.
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
a
 
cooker
 
with
 
an
 
empty
 
pan
 
placed
 
on
 
it,
 
and
 
●
 
bot
 
is
 
carrying
 
a
 
cookable
 
food
 
item.
 
Returns
 
True
 
if
 
possible,
 
False
 
otherwise.
 
 
start_cook(bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Begins
 
cooking
 
at
 
the
 
cooker
 
at
 
tile
 
(target_x,
 
target_y).
 
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
a
 
cooker
 
with
 
an
 
empty
 
pan
 
placed
 
on
 
it,
 
and
 
●
 
bot
 
is
 
carrying
 
a
 
cookable
 
food
 
item.
 
If
 
the
 
food
 
item
 
has
 
been
 
previously
 
cooked,
 
the
 
food
 
will
 
continue
 
cooking
 
at
 
the
 
beginning
 
of
 
the
 
stage
 
it
 
was
 
previously
 
removed
 
from
 
the
 
cooker
 
at.
 
 
Returns
 
True
 
if
 
cooking
 
begins
 
successfully,
 
False
 
otherwise.
 
 
take_from_pan(self, bot_id: int, target_x: Optional[int] = None, 
target_y:
 
Optional[int]
 
=
 
None)
 
->
 
bool:
 
Removes
 
food
 
from
 
the
 
pan
 
at
 
tile
 
(target_x,
 
target_y).

Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
a
 
cooker
 
with
 
a
 
non-empty
 
pan
 
placed
 
on
 
it,
 
and
 
●
 
bot
 
is
 
not
 
carrying
 
anything
 
Returns
 
True
 
if
 
successful,
 
False
 
otherwise.
 
 
 
Plate
 
Functions
 
take_clean_plate(self, bot_id: int, target_x: Optional[int] = None, 
target_y:
 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Take
 
a
 
clean
 
plate
 
from
 
the
 
sink
 
table
 
at
 
coordinates
 
(target_x,
 
target_y).
 
Requirements:
 
●
 
sink
 
table
 
has
 
available
 
clean
 
plates,
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
a
 
sink
 
table
 
tile,
 
and
 
●
 
bot
 
is
 
not
 
holding
 
anything
 
 
Returns
 
True
 
if
 
successful,
 
False
 
otherwise.
 
 
put_dirty_plate_in_sink(self, bot_id: int, target_x: Optional[int] = 
None,
 
target_y:
 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Place
 
a
 
dirty
 
plate
 
in
 
the
 
sink
 
at
 
coordinates
 
(target_x,
 
target_y).
 
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
a
 
sink
 
tile
 
●
 
bot
 
is
 
holding
 
a
 
dirty
 
plate
 
 
Returns
 
True
 
if
 
successful,
 
False
 
otherwise.
 
 
wash_sink(self, bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Wash
 
a
 
dirty
 
plate
 
in
 
the
 
sink
 
at
 
coordinates
 
(target_x,
 
target_y).
 
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
a
 
sink
 
tile
 
●
 
sink
 
contains
 
a
 
dirty
 
plate
 
 
Returns
 
True
 
if
 
successful,
 
False
 
otherwise.

add_food_to_plate(self, bot_id: int, target_x: Optional[int] = None, 
target_y:
 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Either:
 
●
 
add
 
the
 
food
 
item
 
at
 
coordinates
 
(target_x,
 
target_y)
 
to
 
the
 
plate
 
the
 
bot
 
is
 
holding
 
●
 
add
 
the
 
food
 
item
 
the
 
bot
 
is
 
holding
 
to
 
the
 
plate
 
at
 
coordinates
 
(target_x,
 
target_y)
 
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
contains
 
food
 
or
 
a
 
clean
 
plate
 
●
 
bot
 
is
 
holding
 
food
 
or
 
a
 
clean
 
plate
 
 
Returns
 
True
 
if
 
successful,
 
False
 
otherwise.
 
 
 
Submit
 
Functions
 
can_submit(bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Checks
 
if
 
the
 
currently
 
held
 
plate
 
can
 
be
 
submitted.
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
the
 
submit
 
station
 
●
 
bot
 
is
 
holding
 
a
 
clean
 
plate
 
 
Returns
 
True
 
if
 
possible,
 
False
 
otherwise.
 
 
submit(bot_id: int, target_x: Optional[int] = None, target_y: 
Optional[int]
 
=
 
None)
 
->
 
bool
 
Submits
 
the
 
currently
 
held
 
plate.
 
 
Requirements:
 
●
 
target
 
tile
 
(target_x,
 
target_y)
 
is
 
the
 
submit
 
station
 
●
 
bot
 
is
 
holding
 
a
 
clean
 
plate
 
 
Returns
 
True
 
if
 
possible,
 
False
 
otherwise.
 
Warns
 
if
 
no
 
order
 
matches
 
the
 
submission.
 
 
Switch
 
Functions
 
get_switch_info() -> Dict[str, Any] 
Provides
 
information
 
about
 
the
 
switch,
 
including
 
turn,
 
switch
 
duration,
 
and
 
the
 
switch
 
status
 
of
 
both
 
teams.

can_switch_maps() -> bool 
Returns
 
True
 
if
 
the
 
user
 
can
 
switch
 
into
 
the
 
enemy
 
map,
 
False
 
otherwise.Can
 
switch
 
during
 
any
 
time,
 
but
 
can
 
only
 
switch
 
once.
 
switch_maps() -> bool 
Immediately
 
teleports
 
all
 
bots
 
on
 
the
 
user’s
 
team
 
into
 
the
 
enemy
 
map
 
with
 
non-interferring
 
spawns.
 
Does
 
not
 
consume
 
a
 
bot’s
 
move
 
for
 
that
 
turn.
 
Can
 
only
 
be
 
called
 
once
 
per
 
game
 
per
 
team.
 
 
Returns
 
True
 
if
 
successful,
 
false
 
otherwise.
 
 
Item
 
Information
 
item_to_public_dict(it: Optional[Item]) -> Any
 
Provides
 
information
 
about
 
an
 
item
 
such
 
as
 
type,
 
name,
 
and
 
ID.
 
 
Dictionary
 
Items:
 
●
 
type:
 
“Food”,
 
“Plate”,
 
or
 
“Pan”
 
○
 
Food
 
Additional
 
Items
 
■
 
food_name:
 
name
 
of
 
the
 
food
 
■
 
food_id:
 
id
 
number
 
for
 
the
 
food
 
type
 
■
 
chopped:
 
whether
 
or
 
not
 
the
 
food
 
is
 
chopped
 
■
 
cooked_stage:
 
0
 
(uncooked),
 
1(cooked),
 
or
 
2(burnt)
 
○
 
Plate
 
Additional
 
Items
 
■
 
dirty:
 
whether
 
or
 
not
 
the
 
plate
 
is
 
dirty
 
■
 
food:
 
list
 
of
 
dicts
 
with
 
above
 
items
 
○
 
Pan
 
Additional
 
Items
 
■
 
food:
 
a
 
dictionary
 
with
 
information
 
about
 
the
 
food
 
item
 
in
 
the
 
pan
 
 
Game
 
Constants
 
Map 
A
 
class
 
that
 
details
 
the
 
environment
 
 
Convention:
 
bottom-left
 
is
 
[0][0],
 
top-right
 
is
 
[width-1][height-1]
 
 
The
 
map
 
is
 
structured
 
as
 
follows:

y
 
==
 
height
 
-----
 
x
 
==
 
width
    
[[#
 
#
 
#
 
#
 
#
 
#
 
#
 
#],
 
        
|
             
[#
 
#
 
#
 
#
 
#
 
#
 
#
 
#],
 
        
|
             
[#
 
#
 
#
 
#
 
#
 
#
 
#
 
#],
 
        
|
            
[#
 
#
 
#
 
#
 
#
 
#
 
#
 
#],
 
       
v
            
[#
 
#
 
#
 
#
 
#
 
#
 
#
 
#]]
 
 Tile 
A
 
class
 
containing
 
the
 
following
 
ﬁelds:
 
●
 
tile_name:
 
name
 
of
 
the
 
tile
 
●
 
tile_id:
 
id
 
of
 
the
 
tile
 
●
 
is_walkable:
 
whether
 
the
 
tile
 
is
 
walkable
 
●
 
is_dangerous:
 
whether
 
the
 
tile
 
is
 
dangerous
 
●
 
is_placeable:
 
whether
 
items
 
can
 
be
 
placed
 
on
 
the
 
tile
 
●
 
is_interactable:
 
whether
 
the
 
tile
 
can
 
be
 
interacted
 
with
 
 Tile Types 
There
 
are
 
10
 
types
 
of
 
tiles:
 
●
 
Floor:
 
walkable
 
ﬂoor
 
tiles
 
●
 
Wall:
 
unwalkable
 
wall
 
tiles
 
●
 
Counter:
 
unwalkable
 
tiles
 
that
 
items
 
and
 
ingredients
 
can
 
be
 
placed
 
on
 
●
 
Box:
 
unwalkable
 
tiles
 
that
 
multiple
 
ingredients
 
of
 
the
 
same
 
type
 
can
 
be
 
placed
 
in
 
and
 
removed
 
from
 
●
 
Sink:
 
where
 
dirty
 
dishes
 
are
 
placed
 
and
 
washed
 
●
 
SinkTable:
 
where
 
clean
 
dishes
 
appear
 
after
 
being
 
washed
 
●
 
Cooker:
 
where
 
ingredients
 
are
 
cooked
 
●
 
Trash:
 
where
 
food
 
is
 
thrown
 
away
 
●
 
Submit:
 
where
 
orders
 
are
 
submitted
 
●
 
Shop:
 
where
 
ingredients
 
and
 
items
 
can
 
be
 
purchased
 
 Ingredients 
There
 
are
 
5
 
different
 
ingredients
 
that
 
can
 
be
 
processed
 
and
 
purchased.
 
Ingredient
 
 
ID
 
Choppable
 
Cookable
 
Cost
 
Egg
 
0
 
False
 
True
 
20
 
Onion
 
1
 
True
 
False
 
30

Meat
 
2
 
True
 
True
 
80
 
Noodles
 
3
 
False
 
False
 
40
 
Sauce
 
4
 
False
 
False
 
10
 
 Items 
There
 
are
 
2
 
different
 
items
 
that
 
can
 
be
 
purchased
 
from
 
the
 
shop. 
Item 
Cost 
Plate 
2 
Pan 
4
